From: =?gb2312?B?08kgV2luZG93cyBJbnRlcm5ldCBFeHBsb3JlciA4ILGjtOY=?=
Subject: YahooFinance - Ruby Module
Date: Thu, 26 May 2011 19:31:02 +0800
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0000_01CC1BDB.7304BD60"
X-MimeOLE: Produced By Microsoft MimeOLE V6.1.7600.16776

这是 MIME 格式的多方邮件。

------=_NextPart_000_0000_01CC1BDB.7304BD60
Content-Type: text/html;
	charset="utf-8"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.transparentech.com/opensource/yahoofinance

=EF=BB=BF<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns=3D"http://www.w3.org/1999/xhtml"><HEAD><TITLE>YahooFinance - =
Ruby Module</TITLE>
<META content=3D"text/html; charset=3Dutf-8" http-equiv=3Dcontent-type>
<META name=3DDescription=20
content=3D"YahooFinance is a Ruby programming language module for =
retrieving stock quote information from the finance.yahoo.com web site.  =
It can retrieve current stock quote data or historical quote =
data."><LINK=20
rel=3Dstylesheet type=3Dtext/css=20
href=3D"http://www.transparentech.com/stylesheets/tt.css?1264424279" =
media=3Dscreen>
<SCRIPT type=3Dtext/javascript=20
src=3D"http://www.transparentech.com/javascripts/rounded_corners.js?12644=
24279"></SCRIPT>

<SCRIPT type=3Dtext/JavaScript>=0A=
  window.onload =3D function() {=0A=
    settings =3D {=0A=
      tl: { radius: 10 },=0A=
      tr: { radius: 10 },=0A=
      bl: { radius: 10 },=0A=
      br: { radius: 10 },=0A=
      antiAlias: true,=0A=
      autoPad: true=0A=
    }=0A=
    /*var divObj =3D document.getElementById("rightbox"); */=0A=
    var cornersObj =3D new curvyCorners(settings, "bubble");=0A=
    cornersObj.applyCornersToAll();=0A=
  }=0A=
</SCRIPT>

<META name=3DGENERATOR content=3D"MSHTML 8.00.7600.16766"></HEAD>
<BODY>
<DIV id=3Dcontainer>
<DIV id=3Dtitleblock>
<H1>TransparenTech</H1>
<P>An ISV and Software Consultancy</P></DIV>
<DIV id=3Dnavbar>
<UL>
  <LI><A href=3D"http://www.transparentech.com/">Home</A>=20
  <LI><A href=3D"http://www.transparentech.com/software">Software</A>=20
  <LI><A href=3D"http://www.transparentech.com/services">Services</A>=20
  <LI><A href=3D"http://www.transparentech.com/opensource">Open =
Source</A>=20
  <LI><A href=3D"http://www.transparentech.com/contact">Contact</A> =
</LI></UL></DIV>
<DIV id=3Dpage>
<DIV class=3Dyf-block-500px>
<DIV class=3Dbubble>
<H2>Want to track lots of stock ticker symbols?</H2>
<P>Try this <A href=3D"http://www.ultimatestockticker.com/">advanced =
stock ticker=20
software</A> now and track 10s, 100s or even 1000s of stocks easily.</P>
<P><A href=3D"http://www.ultimatestockticker.com/">The Ultimate Stock =
Ticker=20
Software</A></P></DIV></DIV>
<H1>YahooFinance - Ruby Module</H1>
<P><TT>YahooFinance</TT> is a Ruby programming language module for =
retrieving=20
stock quote information from the <A=20
href=3D"http://finance.yahoo.com/">finance.yahoo.com</A> web site. It =
can retrieve=20
current stock quote data or historical quote data.</P>
<P>This module can be "required" and used as a library. Or it can be run =
from=20
the command-line as a script.</P>
<H3>Programatic Usage</H3>
<P>The following is example code using the <TT>YahooFinance</TT> Ruby =
module to=20
retrieve the most recent stock quote data.</P><PRE><STRONG>require =
'yahoofinance'</STRONG>

# Set the type of quote we want to retrieve.
# Available type are:
#  - YahooFinanace::StandardQuote
#  - YahooFinanace::ExtendedQuote
#  - YahooFinanace::RealTimeQuote
<STRONG>quote_type =3D YahooFinance::StandardQuote</STRONG>

# Set the symbols for which we want to retrieve quotes.
# You can include more than one symbol by separating=20
# them with a ',' (comma).
<STRONG>quote_symbols =3D "yhoo,goog"</STRONG>

# Get the quotes from Yahoo! Finance.  The get_quotes method call
# returns a Hash containing one quote object of type "quote_type" for
# each symbol in "quote_symbols".  If a block is given, it will be
# called with the quote object (as in the example below).
<STRONG>YahooFinance::get_quotes( quote_type, quote_symbols ) do |qt|
    puts "QUOTING: #{qt.symbol}"
    puts qt.to_s
end</STRONG>

# You can get the same effect using the quote specific method.
<STRONG>quotes =3D YahooFinance::get_standard_quotes( quote_symbols )
quotes.each do |symbol, qt|
    puts "QUOTING: #{symbol}"
    puts qt.to_s
end</STRONG>
</PRE>
<P>The following is an example of using the <CODE>YahooFinance</CODE> =
Ruby=20
module to download historical quote data.</P><PRE><STRONG>require =
'yahoofinance'</STRONG>

# You can get the historical quote data in 2 formats:=20
#   1. As an array of raw data.
#   2. As a YahooFinance::HistoricalQuote object.

# Getting the historical quote data as a raw array.
# The elements of the array are:
#   [0] - Date
#   [1] - Open
#   [2] - High
#   [3] - Low
#   [4] - Close
#   [5] - Volume
#   [6] - Adjusted Close

# The following example will download 30 days worth of qutoes.
# See the note below on the meaning of the number of days.
<STRONG>YahooFinance::get_historical_quotes_days( 'YHOO', 30 ) do |row|
  puts "YHOO,#{row.join(',')}"
end</STRONG>
# The API also supportes retrieving quotes based on specific dates.
<STRONG>YahooFinance::get_historical_quotes( 'YHOO',=20
                                      Date.parse( '2005-09-09' ),=20
                                      Date.today() ) do |row|
  puts "YHOO,#{row.join(',')}"
end</STRONG>

# Getting the data as YahooFinance::HistoricalQuote objects using the
# days API.
<STRONG>YahooFinance::get_HistoricalQuotes_days( 'YHOO', 30 ) do |hq|
  puts "#{hq.symbol},#{hq.date},#{hq.open},#{hq.high},#{hq.low},"
     + "#{hq.close},#{hq.volume},#{hq.adjClose}"
end</STRONG>
# Getting the data as YahooFinance::HistoricalQuote objects based on
# specific dates.
<STRONG>YahooFinance::get_HistoricalQuotes( 'YHOO',=20
                                     Date.parse( '2005-09-09' ),
                                     Date.today() ) do |hq|
  puts "#{hq.symbol},#{hq.date},#{hq.open},#{hq.high},#{hq.low},"
     + "#{hq.close},#{hq.volume},#{hq.adjClose}"
end</STRONG>

</PRE>
<H3>Command-Line Usage</H3>
<P>The module includes a simple command-line interface.</P><PRE>% =
<STRONG>yahoofinance.rb -h</STRONG>
Usage: yahoofinance.rb [options] &lt;symbol&gt;

    -s                               Retrieve standard quotes (default).
    -x                               Retrieve extended quotes.
    -r                               Retrieve real-time quotes.
    -z                               Retrieve historical quotes.
    -d, --days N                     Number of days of historical=20
                                     quotes to retrieve. Default is 90.
    -h, --help                       Show this message

% <STRONG>yahoofinance.rb -x yhoo</STRONG>
Retrieving quotes for: yhoo
QUOTING: YHOO
YahooFinance::ExtendedQuote
movingAve50daysChangePercentFrom =3D -10.64%
weeks52ChangeFromLow =3D 2.23
annualizedGain =3D -
pricePaid =3D -
weeks52ChangePercentFromLow =3D +8.95%
weeks52Range =3D 24.91 - 43.66
stockExchange =3D NasdaqNM
holdingsGain =3D -
tradeDate =3D -
pegRatio =3D 2.12
dividendYield =3D N/A
name =3D YAHOO INC
dayValueChange =3D - - -1.20%
pricePerEPSEstimateCurrentYear =3D 56.06
oneYearTargetPrice =3D 38.30
dividendPerShare =3D 0.00
shortRatio =3D 6.00
holdingsValue =3D -
commission =3D -
pricePerSales =3D 6.48
pricePerEPSEstimateNextYear =3D 41.00
earningsPerShare =3D 0.848
notes =3D -
highLimit =3D -
movingAve50days =3D 30.372
pricePerBook =3D 4.47
exDividendDate =3D 12-May-04
lowLimit =3D -
movingAve200days =3D 31.911
bookValue =3D 6.149
epsEstimateCurrentYear =3D 0.49
marketCap =3D 38.235B
peRatio =3D 32.39
sharesOwned =3D -
movingAve200daysChangeFrom =3D -4.771
epsEstimateNextYear =3D 0.67
symbol =3D YHOO
movingAve200daysChangePercentFrom =3D -14.95%
epsEstimateNextQuarter =3D 0.16
dividendPayDate =3D N/A
weeks52ChangeFromHigh =3D -16.52
holdingsGainPercent =3D - - -
movingAve50daysChangeFrom =3D -3.232
ebitda =3D 1.849B
weeks52ChangePercentFromHigh =3D -37.84%

<STRONG>% yahoofinance.rb -z -d 10 yhoo</STRONG>
Retrieving quotes for: yhoo
yhoo,31-Jul-06,27.46,27.55,26.99,27.14,16492600,27.14
yhoo,28-Jul-06,26.90,27.50,26.33,27.47,21584800,27.47
yhoo,27-Jul-06,27.35,27.50,26.64,26.70,25153000,26.70
yhoo,26-Jul-06,26.78,27.51,26.57,27.08,20073800,27.08
yhoo,25-Jul-06,26.75,27.19,26.57,26.95,21382900,26.95
yhoo,24-Jul-06,26.24,27.23,25.89,26.94,42631300,26.94
</PRE>
<H3>Note On Historical Quote Retrieval</H3>
<UL>
  <LI>Requests for historical quotes of stocks on some 'international' =
exchanges=20
  are limited by Yahoo! Finance to 200 data points per request. In order =
to=20
  retrieve all of the data points in one method call, the=20
  <CODE>YahooFinance</CODE> Ruby module will internally make multiple =
requests=20
  if the 200 data point limit is detected. Thus, users of the=20
  <CODE>YahooFinance</CODE> Ruby module need not be concerned with this=20
  limitation.=20
  <LI>The API for historical quotes supports selecting the quotes based =
on dates=20
  or a number of days. When using the number of days, it is important to =

  understand that the number of days given does not correspond to actual =

  business days. It corresponds to calendar days and thus the number of =
data=20
  points returned will almost always be less than the number of days =
requested.=20
  <LI>When speed is an issue, using the raw array API is recommended. =
</LI></UL>
<H3>Download</H3>
<P>Current Version</P>
<UL>
  <LI><A=20
  =
href=3D"http://rubyforge.org/frs/download.php/24971/yahoofinance-1.2.2.ge=
m">yahoofinance-1.2.2.gem</A>=20

  <LI><A=20
  =
href=3D"http://rubyforge.org/frs/download.php/24970/yahoofinance-1.2.2.ta=
r.gz">yahoofinance-1.2.2.tar.gz</A>=20
  </LI></UL>
<P><A href=3D"http://rubyforge.org/projects/yahoofinance/">YahooFinance =
RubyForge=20
Page</A></P>
<H3>Installation Instructions</H3>
<P><STRONG>RubyGem Installation</STRONG></P><PRE># gem install =
yahoofinance
</PRE>
<P>or</P><PRE># gem install yahoofinance-&lt;version&gt;.gem
</PRE>
<P><STRONG>Tarball Installation</STRONG></P><PRE>% tar xvzf =
yahoofinance-&lt;version&gt;.tar.gz
% cd yahoofinance-&lt;version&gt;
% ruby setup.rb     =20
</PRE>
<P>You may also be interested in the on-line documentation for <A=20
href=3D"http://i.loveruby.net/en/prog/setup.html">setup.rb</A> .</P>
<H3>Credits/Complaints/Suggestions/Bugs</H3>
<UL>
  <LI><A href=3D"mailto:nickrahn%20at%20users.sourceforge.net">nickrahn =
at=20
  users.sourceforge.net</A> </LI></UL>
<H3>License</H3>
<P>The <TT>YahooFinance</TT> Ruby module is released under the GNU =
General=20
Public License (<A=20
href=3D"http://www.gnu.org/copyleft/gpl.html">GPL</A>).</P></DIV>
<DIV id=3Dfooter>
<DIV class=3Dright>
<P>Copyright =C2=A9 2006-2009 TransparenTech, All Rights =
Reserved</P></DIV>
<P>&nbsp;</P></DIV></DIV>
<SCRIPT type=3Dtext/javascript>=0A=
var gaJsHost =3D (("https:" =3D=3D document.location.protocol) ? =
"https://ssl." : "http://www.");=0A=
document.write(unescape("%3Cscript src=3D'" + gaJsHost + =
"google-analytics.com/ga.js' type=3D'text/javascript'%3E%3C/script%3E"));=0A=
</SCRIPT>

<SCRIPT type=3Dtext/javascript>=0A=
try {=0A=
var pageTracker =3D _gat._getTracker("UA-7216971-2");=0A=
pageTracker._trackPageview();=0A=
} catch(err) {}</SCRIPT>
</BODY></HTML>

------=_NextPart_000_0000_01CC1BDB.7304BD60
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.transparentech.com/stylesheets/tt.css?1264424279

BODY {
	TEXT-ALIGN: center; PADDING-BOTTOM: 0px; BACKGROUND-COLOR: #eee; =
MARGIN: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT-FAMILY: =
verdana, arial, sans-serif; COLOR: #666666; FONT-SIZE: 80%; PADDING-TOP: =
0px
}
IMG {
	BORDER-RIGHT-WIDTH: 0px; BORDER-TOP-WIDTH: 0px; BORDER-BOTTOM-WIDTH: =
0px; BORDER-LEFT-WIDTH: 0px
}
IMG.sme-banner {
	BORDER-RIGHT-WIDTH: 0px; MARGIN: 30px; BORDER-TOP-WIDTH: 0px; =
BORDER-BOTTOM-WIDTH: 0px; BORDER-LEFT-WIDTH: 0px
}
P {
	MARGIN: 0.5em
}
H1 {
	FONT-STYLE: italic; MARGIN: 0px; PADDING-RIGHT: 70px; FONT-FAMILY: =
verdana, arial, sans-serif; COLOR: #3b4471; FONT-SIZE: 150%; =
FONT-WEIGHT: bold
}
H2 {
	PADDING-BOTTOM: 0px; FONT-STYLE: italic; MARGIN: 0px 0.5em; =
PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT-FAMILY: verdana, arial, =
sans-serif; COLOR: #3b4471; FONT-SIZE: 120%; FONT-WEIGHT: bold; =
PADDING-TOP: 0px
}
H3 {
	PADDING-BOTTOM: 0px; FONT-STYLE: italic; MARGIN: 0px 0.5em; =
PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT-FAMILY: verdana, arial, =
sans-serif; COLOR: #3b4471; FONT-SIZE: 100%; FONT-WEIGHT: bold; =
PADDING-TOP: 0px
}
A:link {
	COLOR: #3b4471; TEXT-DECORATION: underline
}
A:visited {
	COLOR: #3b4471; TEXT-DECORATION: underline
}
A:active {
	COLOR: #3b4471; TEXT-DECORATION: underline
}
A:hover {
	COLOR: #8cd749; TEXT-DECORATION: none
}
TABLE {
	BORDER-BOTTOM: #dadada 2px solid; BORDER-LEFT: #dadada 2px solid; =
MARGIN: 5px; BORDER-TOP: #dadada 2px solid; BORDER-RIGHT: #dadada 2px =
solid
}
TABLE.noborder {
	BORDER-RIGHT-WIDTH: 0px; BORDER-TOP-WIDTH: 0px; BORDER-BOTTOM-WIDTH: =
0px; BORDER-LEFT-WIDTH: 0px
}
TH {
	BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white =
1px solid; PADDING-LEFT: 12px; PADDING-RIGHT: 12px; MARGIN-BOTTOM: 1px; =
BACKGROUND: #4088b8; HEIGHT: 25px; COLOR: #ffffff; BORDER-TOP: white 1px =
solid; BORDER-RIGHT: white 1px solid
}
TR {
	MARGIN: 10px; HEIGHT: 25px
}
TD {
	BORDER-BOTTOM: white 1px solid; BORDER-LEFT: white 1px solid; =
PADDING-BOTTOM: 8px; PADDING-LEFT: 8px; PADDING-RIGHT: 8px; FONT-SIZE: =
80%; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; =
PADDING-TOP: 8px
}
TR.rowlight {
	BACKGROUND: #fbfbfb
}
TR.rowdark {
	BACKGROUND: #f1f1f1
}
TD.alignright {
	TEXT-ALIGN: right; VERTICAL-ALIGN: top
}
INPUT {
	BORDER-BOTTOM: #666666 1px solid; BORDER-LEFT: #666666 1px solid; =
BACKGROUND-COLOR: #ffffff; BORDER-TOP: #666666 1px solid; BORDER-RIGHT: =
#666666 1px solid
}
TEXTAREA {
	BORDER-BOTTOM: #666666 1px solid; BORDER-LEFT: #666666 1px solid; =
BACKGROUND-COLOR: #ffffff; BORDER-TOP: #666666 1px solid; BORDER-RIGHT: =
#666666 1px solid
}
INPUT.tt_form_submit {
	BORDER-BOTTOM: #cccccc 1px solid; BORDER-LEFT: #cccccc 1px solid; =
BACKGROUND-COLOR: #aaaaaa; COLOR: #ffffff; BORDER-TOP: #cccccc 1px =
solid; FONT-WEIGHT: normal; BORDER-RIGHT: #cccccc 1px solid
}
BR.clear {
	CLEAR: left
}
.bubble {
	BACKGROUND-COLOR: #dddddd
}
IMG.padding10 {
	PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; =
PADDING-TOP: 10px
}
.yf-block-500px {
	TEXT-ALIGN: center; MARGIN: 20px auto; WIDTH: 500px
}
#container {
	PADDING-BOTTOM: 0px; BACKGROUND-COLOR: #ffffff; MARGIN: 0px auto; =
PADDING-LEFT: 0px; WIDTH: 70%; PADDING-RIGHT: 0px; PADDING-TOP: 0px
}
#titleblock {
	BACKGROUND-IMAGE: url(../images/window-banner.jpg); TEXT-ALIGN: right; =
PADDING-BOTTOM: 2em; MARGIN: 0px; PADDING-LEFT: 2em; PADDING-RIGHT: 2em; =
BACKGROUND-REPEAT: no-repeat; BACKGROUND-POSITION: right center; =
PADDING-TOP: 2em
}
#titleblock H1 {
	FONT-STYLE: italic; MARGIN: 0px; PADDING-RIGHT: 70px; FONT-FAMILY: =
verdana, arial, sans-serif; COLOR: #ffffff; FONT-SIZE: 250%; =
FONT-WEIGHT: normal
}
#titleblock P {
	TEXT-INDENT: 4em; PADDING-RIGHT: 50px; COLOR: #ffffff
}
#navbar UL {
	PADDING-BOTTOM: 0px; LINE-HEIGHT: 1.5em; BACKGROUND-COLOR: #999999; =
LIST-STYLE-TYPE: none; MARGIN: 0px; PADDING-LEFT: 0px; WIDTH: 100%; =
PADDING-RIGHT: 0px; DISPLAY: block; FLOAT: left; CLEAR: both; =
PADDING-TOP: 0px
}
#navbar LI {
	DISPLAY: inline
}
#navbar A {
	PADDING-BOTTOM: 1.2em; BACKGROUND-COLOR: #999999; MARGIN: 0px; =
PADDING-LEFT: 0px; WIDTH: 19.9%; PADDING-RIGHT: 0px; DISPLAY: block; =
FLOAT: left; COLOR: #ffffff; TEXT-DECORATION: none; PADDING-TOP: 1.2em
}
#navbar A:hover {
	BACKGROUND-COLOR: #485780
}
#rightcontainer {
	MARGIN: 1em 0.5em 0.5em; WIDTH: 20em; FLOAT: right
}
.right {
	FLOAT: right
}
.left {
	FLOAT: left
}
.rightbox H2 {
	TEXT-ALIGN: center; BACKGROUND-COLOR: #cccccc; MARGIN: 0px; FONT-SIZE: =
100%; FONT-WEIGHT: normal
}
.rightbox A:hover {
	COLOR: #ffffff
}
.rightbox P {
	TEXT-ALIGN: center; PADDING-BOTTOM: 0px; MARGIN: 0.5em; PADDING-LEFT: =
0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px
}
#footer {
	TEXT-ALIGN: left; PADDING-BOTTOM: 0.8em; MARGIN: 2.5em 0.2em 0.5em =
0.5em; PADDING-LEFT: 0.8em; PADDING-RIGHT: 0.8em; COLOR: #999999; CLEAR: =
both; FONT-SIZE: 75%; BORDER-TOP: #999999 1px solid; PADDING-TOP: 0.8em
}
#footer .right {
	TEXT-ALIGN: right; FLOAT: right; CLEAR: right
}
#footer P {
	MARGIN: 0px
}
#page {
	TEXT-ALIGN: left; PADDING-BOTTOM: 1em; MARGIN: 0px; PADDING-LEFT: 1em; =
PADDING-RIGHT: 1em; CLEAR: left; PADDING-TOP: 1em
}
.block-500px {
	WIDTH: 500px
}
.services-list {
	MARGIN: 3em 2em
}
.services-list H3 {
	PADDING-BOTTOM: 0px; PADDING-LEFT: 0.5em; PADDING-RIGHT: 0px; =
PADDING-TOP: 0px
}
.services-list P {
	PADDING-BOTTOM: 0px; PADDING-LEFT: 0.5em; PADDING-RIGHT: 0px; =
PADDING-TOP: 0px
}
.project {
	MARGIN: 3em 2em
}
.project H3 {
	PADDING-BOTTOM: 0px; PADDING-LEFT: 0.5em; PADDING-RIGHT: 0px; =
PADDING-TOP: 0px
}
.project P {
	PADDING-BOTTOM: 0px; PADDING-LEFT: 0.5em; PADDING-RIGHT: 0px; =
PADDING-TOP: 0px
}
.project .label_left {
	TEXT-ALIGN: right; WIDTH: 6em; MARGIN-RIGHT: 0.5em
}
.project .label_right {
	TEXT-ALIGN: left; MARGIN-LEFT: 0.5em
}
.project .thumb {
	MARGIN: 1em; FLOAT: right
}
#client_login {
	TEXT-ALIGN: center; PADDING-BOTTOM: 2em; MARGIN: 0px auto; =
PADDING-LEFT: 2em; WIDTH: 24em; PADDING-RIGHT: 2em; PADDING-TOP: 2em
}
.login {
	MARGIN: 2em
}
.login .label_left {
	TEXT-ALIGN: right; WIDTH: 6em; FLOAT: left; MARGIN-RIGHT: 0.5em
}
.login .label_right {
	TEXT-ALIGN: left; WIDTH: 10em; FLOAT: left; MARGIN-LEFT: 0.5em
}
.login INPUT.tt_form_submit {
	WIDTH: 5em; DISPLAY: block; FLOAT: left; MARGIN-LEFT: 0.5em
}
.login_result {
	MARGIN: 0.5em; COLOR: red; FONT-WEIGHT: normal
}
#contact_form {
	MARGIN: 2em 3em 3em 2em; WIDTH: 400px
}
#contact_form INPUT {
	WIDTH: 270px; DISPLAY: block; MARGIN-BOTTOM: 0.2em; FLOAT: left; =
MARGIN-RIGHT: 1em
}
#contact_form TEXTAREA {
	WIDTH: 270px; DISPLAY: block; MARGIN-BOTTOM: 0.2em; FLOAT: left; =
MARGIN-RIGHT: 1em
}
#contact_form LABEL {
	TEXT-ALIGN: right; WIDTH: 6em; DISPLAY: block; MARGIN-BOTTOM: 0.2em; =
FLOAT: left; MARGIN-RIGHT: 1em
}
#contact_form INPUT.tt_form_submit {
	WIDTH: 80px
}
.attention {
	BORDER-BOTTOM: red 1px solid; BORDER-LEFT: red 1px solid; =
BACKGROUND-COLOR: #ecd814; MARGIN: 30px; COLOR: #000; BORDER-TOP: red =
1px solid; BORDER-RIGHT: red 1px solid
}
.attention H2 {
	COLOR: #000; FONT-SIZE: 130%
}

------=_NextPart_000_0000_01CC1BDB.7304BD60
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.transparentech.com/javascripts/rounded_corners.js?1264424279


 /****************************************************************
  *                                                              *
  *  curvyCorners                                                *
  *  ------------                                                *
  *                                                              *
  *  This script generates rounded corners for your divs.        *
  *                                                              *
  *  Version 1.2.9                                               *
  *  Copyright (c) 2006 Cameron Cooke                            *
  *  By: Cameron Cooke and Tim Hutchison.                        *
  *                                                              *
  *                                                              *
  *  Website: http://www.curvycorners.net                        *
  *  Email:   info@totalinfinity.com                             *
  *  Forum:   http://www.curvycorners.net/forum/                 *
  *                                                              *
  *                                                              *
  *  This library is free software; you can redistribute         *
  *  it and/or modify it under the terms of the GNU              *
  *  Lesser General Public License as published by the           *
  *  Free Software Foundation; either version 2.1 of the         *
  *  License, or (at your option) any later version.             *
  *                                                              *
  *  This library is distributed in the hope that it will        *
  *  be useful, but WITHOUT ANY WARRANTY; without even the       *
  *  implied warranty of MERCHANTABILITY or FITNESS FOR A        *
  *  PARTICULAR PURPOSE. See the GNU Lesser General Public       *
  *  License for more details.                                   *
  *                                                              *
  *  You should have received a copy of the GNU Lesser           *
  *  General Public License along with this library;             *
  *  Inc., 59 Temple Place, Suite 330, Boston,                   *
  *  MA 02111-1307 USA                                           *
  *                                                              *
  ****************************************************************/

  // Browser detection
  var isIE     =3D navigator.userAgent.toLowerCase().indexOf("msie") > =
-1;
  var isMoz    =3D document.implementation && =
document.implementation.createDocument;
  var isSafari =3D =
((navigator.userAgent.toLowerCase().indexOf('safari')!=3D-1)&&(navigator.=
userAgent.toLowerCase().indexOf('mac')!=3D-1))?true:false;

  /*
  Usage:

  newCornersObj =3D new curvyCorners(settingsObj, "classNameStr");
  newCornersObj =3D new curvyCorners(settingsObj, divObj1[, divObj2[, =
divObj3[, . . . [, divObjN]]]]);
  */
  function curvyCorners()
  {
      // Check parameters
      if(typeof(arguments[0]) !=3D "object") throw newCurvyError("First =
parameter of curvyCorners() must be an object.");
      if(typeof(arguments[1]) !=3D "object" && typeof(arguments[1]) !=3D =
"string") throw newCurvyError("Second parameter of curvyCorners() must =
be an object or a class name.");

      // Get object(s)
      if(typeof(arguments[1]) =3D=3D "string")
      {
          // Get elements by class name
          var startIndex =3D 0;
          var boxCol =3D getElementsByClass(arguments[1]);
      }
      else
      {
          // Get objects
          var startIndex =3D 1;
          var boxCol =3D arguments;
      }

      // Create return collection/object
      var curvyCornersCol =3D new Array();

      // Create array of html elements that can have rounded corners
      if(arguments[0].validTags)
        var validElements =3D arguments[0].validTags;
      else
        var validElements =3D ["div"]; // Default

      // Loop through each argument
      for(var i =3D startIndex, j =3D boxCol.length; i < j; i++)
      {
          // Current element tag name
          var currentTag =3D boxCol[i].tagName.toLowerCase();

          if(inArray(validElements, currentTag) !=3D=3D false)
          {
              curvyCornersCol[curvyCornersCol.length] =3D new =
curvyObject(arguments[0], boxCol[i]);
          }
      }

      this.objects =3D curvyCornersCol;

      // Applys the curvyCorners to all objects
      this.applyCornersToAll =3D function()
      {
          for(var x =3D 0, k =3D this.objects.length; x < k; x++)
          {
              this.objects[x].applyCorners();
          }
      }
  }

  // curvyCorners object (can be called directly)
  function curvyObject()
  {
      // Setup Globals
      this.box              =3D arguments[1];
      this.settings         =3D arguments[0];
      this.topContainer     =3D null;
      this.bottomContainer  =3D null;
      this.masterCorners    =3D new Array();
      this.contentDIV       =3D null;

      // Get box formatting details
      var boxHeight       =3D get_style(this.box, "height", "height");
      var boxWidth        =3D get_style(this.box, "width", "width");
      var borderWidth     =3D get_style(this.box, "borderTopWidth", =
"border-top-width");
      var borderColour    =3D get_style(this.box, "borderTopColor", =
"border-top-color");
      var boxColour       =3D get_style(this.box, "backgroundColor", =
"background-color");
      var backgroundImage =3D get_style(this.box, "backgroundImage", =
"background-image");
      var boxPosition     =3D get_style(this.box, "position", =
"position");
      var boxPadding      =3D get_style(this.box, "paddingTop", =
"padding-top");

      // Set formatting propertes
      this.boxHeight       =3D parseInt(((boxHeight !=3D "" && boxHeight =
!=3D "auto" && boxHeight.indexOf("%") =3D=3D -1)? boxHeight.substring(0, =
boxHeight.indexOf("px")) : this.box.scrollHeight));
      this.boxWidth        =3D parseInt(((boxWidth !=3D "" && boxWidth =
!=3D "auto" && boxWidth.indexOf("%") =3D=3D -1)? boxWidth.substring(0, =
boxWidth.indexOf("px")) : this.box.scrollWidth));
      this.borderWidth     =3D parseInt(((borderWidth !=3D "" && =
borderWidth.indexOf("px") !=3D=3D -1)? borderWidth.slice(0, =
borderWidth.indexOf("px")) : 0));
      this.boxColour       =3D format_colour(boxColour);
      this.boxPadding      =3D parseInt(((boxPadding !=3D "" && =
boxPadding.indexOf("px") !=3D=3D -1)? boxPadding.slice(0, =
boxPadding.indexOf("px")) : 0));
      this.borderColour    =3D format_colour(borderColour);
      this.borderString    =3D this.borderWidth + "px" + " solid " + =
this.borderColour;
      this.backgroundImage =3D ((backgroundImage !=3D "none")? =
backgroundImage : "");
      this.boxContent      =3D this.box.innerHTML;

      // Make box relative if not already absolute and remove any =
padding
      if(boxPosition !=3D "absolute") this.box.style.position =3D =
"relative";
      this.box.style.padding =3D "0px";

      // If IE and height and width are not set, we need to set width so =
that we get positioning
      if(isIE && boxWidth =3D=3D "auto" && boxHeight =3D=3D "auto") =
this.box.style.width =3D "100%";

      // Resize box so that it stays to the orignal height


      // Remove content if box is using autoPad
      if(this.settings.autoPad =3D=3D true && this.boxPadding > 0)
        this.box.innerHTML =3D "";

      /*
      This method creates the corners and
      applies them to the div element.
      */
      this.applyCorners =3D function()
      {
          /*
          Create top and bottom containers.
          These will be used as a parent for the corners and bars.
          */
          for(var t =3D 0; t < 2; t++)
          {
              switch(t)
              {
                  // Top
                  case 0:

                      // Only build top bar if a top corner is to be =
draw
                      if(this.settings.tl || this.settings.tr)
                      {
                          var newMainContainer =3D =
document.createElement("DIV");
                          newMainContainer.style.width    =3D "100%";
                          newMainContainer.style.fontSize =3D "1px";
                          newMainContainer.style.overflow =3D "hidden";
                          newMainContainer.style.position =3D =
"absolute";
                          newMainContainer.style.paddingLeft  =3D =
this.borderWidth + "px";
                          newMainContainer.style.paddingRight =3D =
this.borderWidth + "px";
                          var topMaxRadius =3D Math.max(this.settings.tl =
? this.settings.tl.radius : 0, this.settings.tr ? =
this.settings.tr.radius : 0);
                          newMainContainer.style.height =3D topMaxRadius =
+ "px";
                          newMainContainer.style.top    =3D 0 - =
topMaxRadius + "px";
                          newMainContainer.style.left   =3D 0 - =
this.borderWidth + "px";
                          this.topContainer =3D =
this.box.appendChild(newMainContainer);
                      }
                      break;

                  // Bottom
                  case 1:

                      // Only build bottom bar if a top corner is to be =
draw
                      if(this.settings.bl || this.settings.br)
                      {
                          var newMainContainer =3D =
document.createElement("DIV");
                          newMainContainer.style.width    =3D "100%";
                          newMainContainer.style.fontSize =3D "1px";
                          newMainContainer.style.overflow =3D "hidden";
                          newMainContainer.style.position =3D =
"absolute";
                          newMainContainer.style.paddingLeft  =3D =
this.borderWidth + "px";
                          newMainContainer.style.paddingRight =3D =
this.borderWidth + "px";
                          var botMaxRadius =3D Math.max(this.settings.bl =
? this.settings.bl.radius : 0, this.settings.br ? =
this.settings.br.radius : 0);
                          newMainContainer.style.height  =3D =
botMaxRadius + "px";
                          newMainContainer.style.bottom  =3D  0 - =
botMaxRadius + "px";
                          newMainContainer.style.left    =3D  0 - =
this.borderWidth + "px";
                          this.bottomContainer =3D =
this.box.appendChild(newMainContainer);
                      }
                      break;
              }
          }

          // Turn off current borders
          if(this.topContainer) this.box.style.borderTopWidth =3D "0px";
          if(this.bottomContainer) this.box.style.borderBottomWidth =3D =
"0px";

          // Create array of available corners
          var corners =3D ["tr", "tl", "br", "bl"];

          /*
          Loop for each corner
          */
          for(var i in corners)
          {
              // FIX for prototype lib
              if(i > -1 < 4)
              {
                  // Get current corner type from array
                  var cc =3D corners[i];

                  // Has the user requested the currentCorner be round?
                  if(!this.settings[cc])
                  {
                      // No
                      if(((cc =3D=3D "tr" || cc =3D=3D "tl") && =
this.topContainer !=3D null) || ((cc =3D=3D "br" || cc =3D=3D "bl") && =
this.bottomContainer !=3D null))
                      {
                          // We need to create a filler div to fill the =
space upto the next horzontal corner.
                          var newCorner =3D =
document.createElement("DIV");

                          // Setup corners properties
                          newCorner.style.position =3D "relative";
                          newCorner.style.fontSize =3D "1px";
                          newCorner.style.overflow =3D "hidden";

                          // Add background image?
                          if(this.backgroundImage =3D=3D "")
                            newCorner.style.backgroundColor =3D =
this.boxColour;
                          else
                            newCorner.style.backgroundImage =3D =
this.backgroundImage;

                          switch(cc)
                          {
                              case "tl":
                                  newCorner.style.height      =3D =
topMaxRadius - this.borderWidth + "px";
                                  newCorner.style.marginRight =3D =
this.settings.tr.radius - (this.borderWidth*2) + "px";
                                  newCorner.style.borderLeft  =3D =
this.borderString;
                                  newCorner.style.borderTop   =3D =
this.borderString;
                                  newCorner.style.left        =3D =
-this.borderWidth + "px";
                                  break;

                              case "tr":
                                  newCorner.style.height      =3D =
topMaxRadius - this.borderWidth + "px";
                                  newCorner.style.marginLeft  =3D =
this.settings.tl.radius - (this.borderWidth*2) + "px";
                                  newCorner.style.borderRight =3D =
this.borderString;
                                  newCorner.style.borderTop   =3D =
this.borderString;
                                  newCorner.style.backgroundPosition  =
=3D "-" + (topMaxRadius + this.borderWidth) + "px 0px";
                                  newCorner.style.left        =3D =
this.borderWidth + "px";
                                  break;

                              case "bl":
                                  newCorner.style.height       =3D =
botMaxRadius - this.borderWidth + "px";
                                  newCorner.style.marginRight  =3D =
this.settings.br.radius - (this.borderWidth*2) + "px";
                                  newCorner.style.borderLeft   =3D =
this.borderString;
                                  newCorner.style.borderBottom =3D =
this.borderString;
                                  newCorner.style.left         =3D =
-this.borderWidth + "px";
                                  newCorner.style.backgroundPosition =3D =
"-" + (this.borderWidth) + "px -" + (this.boxHeight + (botMaxRadius + =
this.borderWidth)) + "px";
                                  break;

                              case "br":
                                  newCorner.style.height       =3D =
botMaxRadius - this.borderWidth + "px";
                                  newCorner.style.marginLeft   =3D =
this.settings.bl.radius - (this.borderWidth*2) + "px";
                                  newCorner.style.borderRight  =3D =
this.borderString;
                                  newCorner.style.borderBottom =3D =
this.borderString;
                                  newCorner.style.left         =3D =
this.borderWidth + "px"
                                  newCorner.style.backgroundPosition =3D =
"-" + (botMaxRadius + this.borderWidth) + "px -" + (this.boxHeight + =
(botMaxRadius + this.borderWidth)) + "px";
                                  break;
                          }
                      }
                  }
                  else
                  {
                      /*
                      PERFORMANCE NOTE:

                      If more than one corner is requested and a corner =
has been already
                      created for the same radius then that corner will =
be used as a master and cloned.
                      The pixel bars will then be repositioned to form =
the new corner type.
                      All new corners start as a bottom right corner.
                      */
                      if(this.masterCorners[this.settings[cc].radius])
                      {
                          // Create clone of the master corner
                          var newCorner =3D =
this.masterCorners[this.settings[cc].radius].cloneNode(true);
                      }
                      else
                      {
                          // Yes, we need to create a new corner
                          var newCorner =3D =
document.createElement("DIV");
                          newCorner.style.height =3D =
this.settings[cc].radius + "px";
                          newCorner.style.width  =3D =
this.settings[cc].radius + "px";
                          newCorner.style.position =3D "absolute";
                          newCorner.style.fontSize =3D "1px";
                          newCorner.style.overflow =3D "hidden";

                          // THE FOLLOWING BLOCK OF CODE CREATES A =
ROUNDED CORNER
                          // =
---------------------------------------------------- TOP

                          // Get border radius
                          var borderRadius =3D =
parseInt(this.settings[cc].radius - this.borderWidth);

                          // Cycle the x-axis
                          for(var intx =3D 0, j =3D =
this.settings[cc].radius; intx < j; intx++)
                          {
                              // Calculate the value of y1 which =
identifies the pixels inside the border
                              if((intx +1) >=3D borderRadius)
                                var y1 =3D -1;
                              else
                                var y1 =3D =
(Math.floor(Math.sqrt(Math.pow(borderRadius, 2) - Math.pow((intx+1), =
2))) - 1);

                              // Only calculate y2 and y3 if there is a =
border defined
                              if(borderRadius !=3D j)
                              {
                                  if((intx) >=3D borderRadius)
                                    var y2 =3D -1;
                                  else
                                    var y2 =3D =
Math.ceil(Math.sqrt(Math.pow(borderRadius,2) - Math.pow(intx, 2)));

                                  if((intx+1) >=3D j)
                                    var y3 =3D -1;
                                  else
                                    var y3 =3D =
(Math.floor(Math.sqrt(Math.pow(j ,2) - Math.pow((intx+1), 2))) - 1);
                              }

                              // Calculate y4
                              if((intx) >=3D j)
                                var y4 =3D -1;
                              else
                                var y4 =3D =
Math.ceil(Math.sqrt(Math.pow(j ,2) - Math.pow(intx, 2)));

                              // Draw bar on inside of the border with =
foreground colour
                              if(y1 > -1) this.drawPixel(intx, 0, =
this.boxColour, 100, (y1+1), newCorner, -1, this.settings[cc].radius);

                              // Only draw border/foreground antialiased =
pixels and border if there is a border defined
                              if(borderRadius !=3D j)
                              {
                                  // Cycle the y-axis
                                  for(var inty =3D (y1 + 1); inty < y2; =
inty++)
                                  {
                                      // Draw anti-alias pixels
                                      if(this.settings.antiAlias)
                                      {
                                          // For each of the pixels that =
need anti aliasing between the foreground and border colour draw single =
pixel divs
                                          if(this.backgroundImage !=3D =
"")
                                          {
                                              var borderFract =3D =
(pixelFraction(intx, inty, borderRadius) * 100);

                                              if(borderFract < 30)
                                              {
										                                        this.drawPixel(intx, =
inty, this.borderColour, 100, 1, newCorner, 0, =
this.settings[cc].radius);
                                              }
									                                     else
                                              {
									                                         this.drawPixel(intx, =
inty, this.borderColour, 100, 1, newCorner, -1, =
this.settings[cc].radius);
                                              }
                                          }
                                          else
                                          {
                                              var pixelcolour =3D =
BlendColour(this.boxColour, this.borderColour, pixelFraction(intx, inty, =
borderRadius));
                                              this.drawPixel(intx, inty, =
pixelcolour, 100, 1, newCorner, 0, this.settings[cc].radius, cc);
                                          }
                                      }
                                  }

                                  // Draw bar for the border
                                  if(this.settings.antiAlias)
                                  {
                                      if(y3 >=3D y2)
                                      {
                                         if (y2 =3D=3D -1) y2 =3D 0;
                                         this.drawPixel(intx, y2, =
this.borderColour, 100, (y3 - y2 + 1), newCorner, 0, 0);
                                      }
                                  }
                                  else
                                  {
                                      if(y3 >=3D y1)
                                      {
                                          this.drawPixel(intx, (y1 + 1), =
this.borderColour, 100, (y3 - y1), newCorner, 0, 0);
                                      }
                                  }

                                  // Set the colour for the outside =
curve
                                  var outsideColour =3D =
this.borderColour;
                              }
                              else
                              {
                                  // Set the coour for the outside curve
                                  var outsideColour =3D this.boxColour;
                                  var y3 =3D y1;
                              }

                              // Draw aa pixels?
                              if(this.settings.antiAlias)
                              {
                                  // Cycle the y-axis and draw the anti =
aliased pixels on the outside of the curve
                                  for(var inty =3D (y3 + 1); inty < y4; =
inty++)
                                  {
                                      // For each of the pixels that =
need anti aliasing between the foreground/border colour & background =
draw single pixel divs
                                      this.drawPixel(intx, inty, =
outsideColour, (pixelFraction(intx, inty , j) * 100), 1, newCorner, =
((this.borderWidth > 0)? 0 : -1), this.settings[cc].radius);
                                  }
                              }
                          }

                          // END OF CORNER CREATION
                          // =
---------------------------------------------------- END

                          // We now need to store the current corner in =
the masterConers array
                          this.masterCorners[this.settings[cc].radius] =
=3D newCorner.cloneNode(true);
                      }

                      /*
                      Now we have a new corner we need to reposition all =
the pixels unless
                      the current corner is the bottom right.
                      */
                      if(cc !=3D "br")
                      {
                          // Loop through all children (pixel bars)
                          for(var t =3D 0, k =3D =
newCorner.childNodes.length; t < k; t++)
                          {
                              // Get current pixel bar
                              var pixelBar =3D newCorner.childNodes[t];

                              // Get current top and left properties
                              var pixelBarTop    =3D =
parseInt(pixelBar.style.top.substring(0, =
pixelBar.style.top.indexOf("px")));
                              var pixelBarLeft   =3D =
parseInt(pixelBar.style.left.substring(0, =
pixelBar.style.left.indexOf("px")));
                              var pixelBarHeight =3D =
parseInt(pixelBar.style.height.substring(0, =
pixelBar.style.height.indexOf("px")));

                              // Reposition pixels
                              if(cc =3D=3D "tl" || cc =3D=3D "bl"){
                                  pixelBar.style.left =3D =
this.settings[cc].radius -pixelBarLeft -1 + "px"; // Left
                              }
                              if(cc =3D=3D "tr" || cc =3D=3D "tl"){
                                  pixelBar.style.top =3D  =
this.settings[cc].radius -pixelBarHeight -pixelBarTop + "px"; // Top
                              }

                              switch(cc)
                              {
                                  case "tr":
                                      pixelBar.style.backgroundPosition  =
=3D "-" + Math.abs((this.boxWidth - this.settings[cc].radius + =
this.borderWidth) + pixelBarLeft) + "px -" + =
Math.abs(this.settings[cc].radius -pixelBarHeight -pixelBarTop - =
this.borderWidth) + "px";
                                      break;

                                  case "tl":
                                      pixelBar.style.backgroundPosition =
=3D "-" + Math.abs((this.settings[cc].radius -pixelBarLeft -1)  - =
this.borderWidth) + "px -" + Math.abs(this.settings[cc].radius =
-pixelBarHeight -pixelBarTop - this.borderWidth) + "px";
                                      break;

                                  case "bl":
                                      pixelBar.style.backgroundPosition =
=3D "-" + Math.abs((this.settings[cc].radius -pixelBarLeft -1) - =
this.borderWidth) + "px -" + Math.abs((this.boxHeight + =
this.settings[cc].radius + pixelBarTop) -this.borderWidth) + "px";
                                      break;
                              }
                          }
                      }
                  }

                  if(newCorner)
                  {
                      // Position the container
                      switch(cc)
                      {
                          case "tl":
                            if(newCorner.style.position =3D=3D =
"absolute") newCorner.style.top  =3D "0px";
                            if(newCorner.style.position =3D=3D =
"absolute") newCorner.style.left =3D "0px";
                            if(this.topContainer) =
this.topContainer.appendChild(newCorner);
                            break;

                          case "tr":
                            if(newCorner.style.position =3D=3D =
"absolute") newCorner.style.top  =3D "0px";
                            if(newCorner.style.position =3D=3D =
"absolute") newCorner.style.right =3D "0px";
                            if(this.topContainer) =
this.topContainer.appendChild(newCorner);
                            break;

                          case "bl":
                            if(newCorner.style.position =3D=3D =
"absolute") newCorner.style.bottom  =3D "0px";
                            if(newCorner.style.position =3D=3D =
"absolute") newCorner.style.left =3D "0px";
                            if(this.bottomContainer) =
this.bottomContainer.appendChild(newCorner);
                            break;

                          case "br":
                            if(newCorner.style.position =3D=3D =
"absolute") newCorner.style.bottom   =3D "0px";
                            if(newCorner.style.position =3D=3D =
"absolute") newCorner.style.right =3D "0px";
                            if(this.bottomContainer) =
this.bottomContainer.appendChild(newCorner);
                            break;
                      }
                  }
              }
          }

          /*
          The last thing to do is draw the rest of the filler DIVs.
          We only need to create a filler DIVs when two corners have
          diffrent radiuses in either the top or bottom container.
          */

          // Find out which corner has the biiger radius and get the =
difference amount
          var radiusDiff =3D new Array();
          radiusDiff["t"] =3D Math.abs(this.settings.tl.radius - =
this.settings.tr.radius)
          radiusDiff["b"] =3D Math.abs(this.settings.bl.radius - =
this.settings.br.radius);

          for(z in radiusDiff)
          {
              // FIX for prototype lib
              if(z =3D=3D "t" || z =3D=3D "b")
              {
                  if(radiusDiff[z])
                  {
                      // Get the type of corner that is the smaller one
                      var smallerCornerType =3D ((this.settings[z + =
"l"].radius < this.settings[z + "r"].radius)? z +"l" : z +"r");

                      // First we need to create a DIV for the space =
under the smaller corner
                      var newFiller =3D document.createElement("DIV");
                      newFiller.style.height =3D radiusDiff[z] + "px";
                      newFiller.style.width  =3D  =
this.settings[smallerCornerType].radius+ "px"
                      newFiller.style.position =3D "absolute";
                      newFiller.style.fontSize =3D "1px";
                      newFiller.style.overflow =3D "hidden";
                      newFiller.style.backgroundColor =3D =
this.boxColour;
                      //newFiller.style.backgroundColor =3D =
get_random_color();

                      // Position filler
                      switch(smallerCornerType)
                      {
                          case "tl":
                              newFiller.style.bottom =3D "0px";
                              newFiller.style.left   =3D "0px";
                              newFiller.style.borderLeft =3D =
this.borderString;
                              this.topContainer.appendChild(newFiller);
                              break;

                          case "tr":
                              newFiller.style.bottom =3D "0px";
                              newFiller.style.right  =3D "0px";
                              newFiller.style.borderRight =3D =
this.borderString;
                              this.topContainer.appendChild(newFiller);
                              break;

                          case "bl":
                              newFiller.style.top    =3D "0px";
                              newFiller.style.left   =3D "0px";
                              newFiller.style.borderLeft =3D =
this.borderString;
                              =
this.bottomContainer.appendChild(newFiller);
                              break;

                          case "br":
                              newFiller.style.top    =3D "0px";
                              newFiller.style.right  =3D "0px";
                              newFiller.style.borderRight =3D =
this.borderString;
                              =
this.bottomContainer.appendChild(newFiller);
                              break;
                      }
                  }

                  // Create the bar to fill the gap between each corner =
horizontally
                  var newFillerBar =3D document.createElement("DIV");
                  newFillerBar.style.position =3D "relative";
                  newFillerBar.style.fontSize =3D "1px";
                  newFillerBar.style.overflow =3D "hidden";
                  newFillerBar.style.backgroundColor =3D this.boxColour;
                  newFillerBar.style.backgroundImage =3D =
this.backgroundImage;

                  switch(z)
                  {
                      case "t":
                          // Top Bar
                          if(this.topContainer)
                          {
                              // Edit by Asger Hallas: Check if =
settings.xx.radius is not false
                              if(this.settings.tl.radius && =
this.settings.tr.radius)
                              {
                                  newFillerBar.style.height      =3D =
topMaxRadius - this.borderWidth + "px";
                                  newFillerBar.style.marginLeft  =3D =
this.settings.tl.radius - this.borderWidth + "px";
                                  newFillerBar.style.marginRight =3D =
this.settings.tr.radius - this.borderWidth + "px";
                                  newFillerBar.style.borderTop   =3D =
this.borderString;

                                  if(this.backgroundImage !=3D "")
                                    =
newFillerBar.style.backgroundPosition  =3D "-" + (topMaxRadius + =
this.borderWidth) + "px 0px";

                                  =
this.topContainer.appendChild(newFillerBar);
                              }

                              // Repos the boxes background image
                              this.box.style.backgroundPosition      =3D =
"0px -" + (topMaxRadius - this.borderWidth) + "px";
                          }
                          break;

                      case "b":
                          if(this.bottomContainer)
                          {
                              // Edit by Asger Hallas: Check if =
settings.xx.radius is not false
                              if(this.settings.bl.radius && =
this.settings.br.radius)
                              {
                                  // Bottom Bar
                                  newFillerBar.style.height       =3D =
botMaxRadius - this.borderWidth + "px";
                                  newFillerBar.style.marginLeft   =3D =
this.settings.bl.radius - this.borderWidth + "px";
                                  newFillerBar.style.marginRight  =3D =
this.settings.br.radius - this.borderWidth + "px";
                                  newFillerBar.style.borderBottom =3D =
this.borderString;

                                  if(this.backgroundImage !=3D "")
                                    =
newFillerBar.style.backgroundPosition  =3D "-" + (botMaxRadius + =
this.borderWidth) + "px -" + (this.boxHeight + (topMaxRadius + =
this.borderWidth)) + "px";

                                  =
this.bottomContainer.appendChild(newFillerBar);
                              }
                          }
                          break;
                  }
              }
          }

          /*
          AutoPad! apply padding if set.
          */
          if(this.settings.autoPad =3D=3D true && this.boxPadding > 0)
          {
              // Create content container
              var contentContainer =3D document.createElement("DIV");

              // Set contentContainer's properties
              contentContainer.style.position =3D "relative";
              contentContainer.innerHTML      =3D this.boxContent;
              contentContainer.className      =3D "autoPadDiv";

              // Get padding amounts
              var topPadding =3D Math.abs(topMaxRadius - =
this.boxPadding);
              var botPadding =3D Math.abs(botMaxRadius - =
this.boxPadding);

              // Apply top padding
              if(topMaxRadius < this.boxPadding)
                contentContainer.style.paddingTop =3D topPadding + "px";

              // Apply Bottom padding
              if(botMaxRadius < this.boxPadding)
                contentContainer.style.paddingBottom =3D botMaxRadius + =
"px";

              // Apply left and right padding
              contentContainer.style.paddingLeft =3D this.boxPadding + =
"px";
              contentContainer.style.paddingRight =3D this.boxPadding + =
"px";

              // Append contentContainer
              this.contentDIV =3D =
this.box.appendChild(contentContainer);
          }
      }

      /*
      This function draws the pixles
      */
      this.drawPixel =3D function(intx, inty, colour, transAmount, =
height, newCorner, image, cornerRadius)
      {
          // Create pixel
          var pixel =3D document.createElement("DIV");
          pixel.style.height   =3D height + "px";
          pixel.style.width    =3D "1px";
          pixel.style.position =3D "absolute";
          pixel.style.fontSize =3D "1px";
          pixel.style.overflow =3D "hidden";

          // Max Top Radius
          var topMaxRadius =3D Math.max(this.settings["tr"].radius, =
this.settings["tl"].radius);

          // Dont apply background image to border pixels
          if(image =3D=3D -1 && this.backgroundImage !=3D "")
          {
              pixel.style.backgroundImage =3D this.backgroundImage;
			           pixel.style.backgroundPosition  =3D "-" + (this.boxWidth - =
(cornerRadius - intx) + this.borderWidth) + "px -" + ((this.boxHeight + =
topMaxRadius + inty) -this.borderWidth) + "px";
		        }
          else
          {
              pixel.style.backgroundColor =3D colour;
          }

          // Set opacity if the transparency is anything other than 100
          if (transAmount !=3D 100)
            setOpacity(pixel, transAmount);

          // Set the pixels position
          pixel.style.top =3D inty + "px";
          pixel.style.left =3D intx + "px";

          newCorner.appendChild(pixel);
      }
  }

  // ------------- UTILITY FUNCTIONS

  // Inserts a element after another
  function insertAfter(parent, node, referenceNode)
  {
	     parent.insertBefore(node, referenceNode.nextSibling);
  }

  /*
  Blends the two colours by the fraction
  returns the resulting colour as a string in the format "#FFFFFF"
  */
  function BlendColour(Col1, Col2, Col1Fraction)
  {
      var red1 =3D parseInt(Col1.substr(1,2),16);
      var green1 =3D parseInt(Col1.substr(3,2),16);
      var blue1 =3D parseInt(Col1.substr(5,2),16);
      var red2 =3D parseInt(Col2.substr(1,2),16);
      var green2 =3D parseInt(Col2.substr(3,2),16);
      var blue2 =3D parseInt(Col2.substr(5,2),16);

      if(Col1Fraction > 1 || Col1Fraction < 0) Col1Fraction =3D 1;

      var endRed =3D Math.round((red1 * Col1Fraction) + (red2 * (1 - =
Col1Fraction)));
      if(endRed > 255) endRed =3D 255;
      if(endRed < 0) endRed =3D 0;

      var endGreen =3D Math.round((green1 * Col1Fraction) + (green2 * (1 =
- Col1Fraction)));
      if(endGreen > 255) endGreen =3D 255;
      if(endGreen < 0) endGreen =3D 0;

      var endBlue =3D Math.round((blue1 * Col1Fraction) + (blue2 * (1 - =
Col1Fraction)));
      if(endBlue > 255) endBlue =3D 255;
      if(endBlue < 0) endBlue =3D 0;

      return "#" + IntToHex(endRed)+ IntToHex(endGreen)+ =
IntToHex(endBlue);
  }

  /*
  Converts a number to hexadecimal format
  */
  function IntToHex(strNum)
  {
      base =3D strNum / 16;
      rem =3D strNum % 16;
      base =3D base - (rem / 16);
      baseS =3D MakeHex(base);
      remS =3D MakeHex(rem);

      return baseS + '' + remS;
  }


  /*
  gets the hex bits of a number
  */
  function MakeHex(x)
  {
      if((x >=3D 0) && (x <=3D 9))
      {
          return x;
      }
      else
      {
          switch(x)
          {
              case 10: return "A";
              case 11: return "B";
              case 12: return "C";
              case 13: return "D";
              case 14: return "E";
              case 15: return "F";
          }
      }
  }


  /*
  For a pixel cut by the line determines the fraction of the pixel on =
the 'inside' of the
  line.  Returns a number between 0 and 1
  */
  function pixelFraction(x, y, r)
  {
      var pixelfraction =3D 0;

      /*
      determine the co-ordinates of the two points on the perimeter of =
the pixel that the
      circle crosses
      */
      var xvalues =3D new Array(1);
      var yvalues =3D new Array(1);
      var point =3D 0;
      var whatsides =3D "";

      // x + 0 =3D Left
      var intersect =3D Math.sqrt((Math.pow(r,2) - Math.pow(x,2)));

      if ((intersect >=3D y) && (intersect < (y+1)))
      {
          whatsides =3D "Left";
          xvalues[point] =3D 0;
          yvalues[point] =3D intersect - y;
          point =3D  point + 1;
      }
      // y + 1 =3D Top
      var intersect =3D Math.sqrt((Math.pow(r,2) - Math.pow(y+1,2)));

      if ((intersect >=3D x) && (intersect < (x+1)))
      {
          whatsides =3D whatsides + "Top";
          xvalues[point] =3D intersect - x;
          yvalues[point] =3D 1;
          point =3D point + 1;
      }
      // x + 1 =3D Right
      var intersect =3D Math.sqrt((Math.pow(r,2) - Math.pow(x+1,2)));

      if ((intersect >=3D y) && (intersect < (y+1)))
      {
          whatsides =3D whatsides + "Right";
          xvalues[point] =3D 1;
          yvalues[point] =3D intersect - y;
          point =3D  point + 1;
      }
      // y + 0 =3D Bottom
      var intersect =3D Math.sqrt((Math.pow(r,2) - Math.pow(y,2)));

      if ((intersect >=3D x) && (intersect < (x+1)))
      {
          whatsides =3D whatsides + "Bottom";
          xvalues[point] =3D intersect - x;
          yvalues[point] =3D 0;
      }

      /*
      depending on which sides of the perimeter of the pixel the circle =
crosses calculate the
      fraction of the pixel inside the circle
      */
      switch (whatsides)
      {
              case "LeftRight":
              pixelfraction =3D Math.min(yvalues[0],yvalues[1]) + =
((Math.max(yvalues[0],yvalues[1]) - Math.min(yvalues[0],yvalues[1]))/2);
              break;

              case "TopRight":
              pixelfraction =3D 1-(((1-xvalues[0])*(1-yvalues[1]))/2);
              break;

              case "TopBottom":
              pixelfraction =3D Math.min(xvalues[0],xvalues[1]) + =
((Math.max(xvalues[0],xvalues[1]) - Math.min(xvalues[0],xvalues[1]))/2);
              break;

              case "LeftBottom":
              pixelfraction =3D (yvalues[0]*xvalues[1])/2;
              break;

              default:
              pixelfraction =3D 1;
      }

      return pixelfraction;
  }


  // This function converts CSS rgb(x, x, x) to hexadecimal
  function rgb2Hex(rgbColour)
  {
      try{

          // Get array of RGB values
          var rgbArray =3D rgb2Array(rgbColour);

          // Get RGB values
          var red   =3D parseInt(rgbArray[0]);
          var green =3D parseInt(rgbArray[1]);
          var blue  =3D parseInt(rgbArray[2]);

          // Build hex colour code
          var hexColour =3D "#" + IntToHex(red) + IntToHex(green) + =
IntToHex(blue);
      }
      catch(e){

          alert("There was an error converting the RGB value to =
Hexadecimal in function rgb2Hex");
      }

      return hexColour;
  }

  // Returns an array of rbg values
  function rgb2Array(rgbColour)
  {
      // Remove rgb()
      var rgbValues =3D rgbColour.substring(4, rgbColour.indexOf(")"));

      // Split RGB into array
      var rgbArray =3D rgbValues.split(", ");

      return rgbArray;
  }

  /*
  Function by Simon Willison from sitepoint.com
  Modified by Cameron Cooke adding Safari's rgba support
  */
  function setOpacity(obj, opacity)
  {
      opacity =3D (opacity =3D=3D 100)?99.999:opacity;

      if(isSafari && obj.tagName !=3D "IFRAME")
      {
          // Get array of RGB values
          var rgbArray =3D rgb2Array(obj.style.backgroundColor);

          // Get RGB values
          var red   =3D parseInt(rgbArray[0]);
          var green =3D parseInt(rgbArray[1]);
          var blue  =3D parseInt(rgbArray[2]);

          // Safari using RGBA support
          obj.style.backgroundColor =3D "rgba(" + red + ", " + green + =
", " + blue + ", " + opacity/100 + ")";
      }
      else if(typeof(obj.style.opacity) !=3D "undefined")
      {
          // W3C
          obj.style.opacity =3D opacity/100;
      }
      else if(typeof(obj.style.MozOpacity) !=3D "undefined")
      {
          // Older Mozilla
          obj.style.MozOpacity =3D opacity/100;
      }
      else if(typeof(obj.style.filter) !=3D "undefined")
      {
          // IE
          obj.style.filter =3D "alpha(opacity:" + opacity + ")";
      }
      else if(typeof(obj.style.KHTMLOpacity) !=3D "undefined")
      {
          // Older KHTML Based Browsers
          obj.style.KHTMLOpacity =3D opacity/100;
      }
  }

  /*
  Returns index if the passed value is found in the
  array otherwise returns false.
  */
  function inArray(array, value)
  {
      for(var i =3D 0; i < array.length; i++){

          // Matches identical (=3D=3D=3D), not just similar (=3D=3D).
          if (array[i] =3D=3D=3D value) return i;
      }

      return false;
  }

  /*
  Returns true if the passed value is found as a key
  in the array otherwise returns false.
  */
  function inArrayKey(array, value)
  {
      for(key in array){

          // Matches identical (=3D=3D=3D), not just similar (=3D=3D).
          if(key =3D=3D=3D value) return true;
      }

      return false;
  }

  // Cross browser add event wrapper
  function addEvent(elm, evType, fn, useCapture) {
	  if (elm.addEventListener) {
		  elm.addEventListener(evType, fn, useCapture);
		  return true;
	  }
	  else if (elm.attachEvent) {
		  var r =3D elm.attachEvent('on' + evType, fn);
		  return r;
	  }
	  else {
		  elm['on' + evType] =3D fn;
	  }
  }

  // Cross browser remove event wrapper
  function removeEvent(obj, evType, fn, useCapture){
    if (obj.removeEventListener){
      obj.removeEventListener(evType, fn, useCapture);
      return true;
    } else if (obj.detachEvent){
      var r =3D obj.detachEvent("on"+evType, fn);
      return r;
    } else {
      alert("Handler could not be removed");
    }
  }

  // Formats colours
  function format_colour(colour)
  {
      var returnColour =3D "#ffffff";

      // Make sure colour is set and not transparent
      if(colour !=3D "" && colour !=3D "transparent")
      {
          // RGB Value?
          if(colour.substr(0, 3) =3D=3D "rgb")
          {
              // Get HEX aquiv.
              returnColour =3D rgb2Hex(colour);
          }
          else if(colour.length =3D=3D 4)
          {
              // 3 chr colour code add remainder
              returnColour =3D "#" + colour.substring(1, 2) + =
colour.substring(1, 2) + colour.substring(2, 3) + colour.substring(2, 3) =
+ colour.substring(3, 4) + colour.substring(3, 4);
          }
          else
          {
              // Normal valid hex colour
              returnColour =3D colour;
          }
      }

      return returnColour;
  }

  // Returns the style value for the property specfied
  function get_style(obj, property, propertyNS)
  {
      try
      {
          if(obj.currentStyle)
          {
              var returnVal =3D eval("obj.currentStyle." + property);
          }
          else
          {
              /*
              Safari does not expose any information for the object if =
display is
              set to none is set so we temporally enable it.
              */
              if(isSafari && obj.style.display =3D=3D "none")
              {
                obj.style.display =3D "";
                var wasHidden =3D true;
              }

              var returnVal =3D =
document.defaultView.getComputedStyle(obj, =
'').getPropertyValue(propertyNS);

              // Rehide the object
              if(isSafari && wasHidden)
              {
                  obj.style.display =3D "none";
              }
          }
      }
      catch(e)
      {
          // Do nothing
      }

      return returnVal;
  }

  // Get elements by class by Dustin Diaz.
  function getElementsByClass(searchClass, node, tag)
  {
	     var classElements =3D new Array();

      if(node =3D=3D null)
		      node =3D document;
	     if(tag =3D=3D null)
		      tag =3D '*';

	     var els =3D node.getElementsByTagName(tag);
	     var elsLen =3D els.length;
	     var pattern =3D new RegExp("(^|\s)"+searchClass+"(\s|$)");

	     for (i =3D 0, j =3D 0; i < elsLen; i++)
      {
		        if(pattern.test(els[i].className))
          {
			           classElements[j] =3D els[i];
			           j++;
		        }
	     }

	     return classElements;
  }

  // Displays error message
  function newCurvyError(errorMessage)
  {
      return new Error("curvyCorners Error:\n" + errorMessage)
  }
------=_NextPart_000_0000_01CC1BDB.7304BD60--
